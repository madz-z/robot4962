#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorFL,       tmotorTetrix, openLoop, driveLeft, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorRL,       tmotorTetrix, openLoop, driveLeft, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorFR,       tmotorTetrix, openLoop, reversed, driveRight, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorRR,       tmotorTetrix, openLoop, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

void initializeRobot()
{

} // initializeRobot

int convert_joystick_to_motor (short a_joystick_value)

{
    //,
    // Set the default speed and direction to 0 and one, respectively.
    //
    float speed = 0;
    short direction = 1;

    //
    // If the specified joystick value is [-27,27], then set the speed to the
    // absolute value of the joystick value and subtract 28.  This margin allows
    // for a dead zone (noise) within the joystick hardware.
    //
    if ((a_joystick_value < -28) || (a_joystick_value > 28))
    {
        speed = abs (a_joystick_value) - 28;
    }
    //
    // If the specified joystick value is greater than zero, then set the
    // direction to a negative value (-1) (i.e. pushing a joystick away from the
    // human has a negative value, so negate it to drive the robot "forward").
    // This will depend on how your robot is wired and/or how the pragmas are
    // configured.
    //
    if (a_joystick_value < 0)
    {
        direction = -1;
    }

    //
    // Return the speed multiplied by the direction.
    //
    return (speed * direction);

} // convert_joystick_to_motor


task main()
{

  initializeRobot();

  //waitForStart();

   while(true)
     {
      //User Control code goes here.
             //
        // Read the current values of the joystick controllers.
        //
        //hogCPU (); // Prevent the messaging task from writing to it while it is being read.
        //getJoystickSettings (joystick); // Added to template for kick-off presentation
        //releaseCPU ();

        //
        // Manage power to the drive wheels.
        //
        motor[motorD] = joystick.joy1_y1/1.28;
        motor[motorG] = joystick.joy1_y1/1.28;
        motor[motorE] = -joystick.joy1_y2/1.28;
        motor[motorF] = -joystick.joy1_y2/1.28;

		}
//motor[motorD]=50;
//motor[motorE]=-50;
//motor[motorF]=-50;
//motor[motorG]=50;
//wait1Msec (2000);
//motor[motorD]=0;
}
